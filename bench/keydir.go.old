/*
   Impletation of keydir
   | --- |      | --------------------------------------------------------------------------|
   | key | -->  | file id (int32) | value size (int32) | value pos (int32) | tstamp (int64) |
   | --- |      | --------------------------------------------------------------------------|
*/

package main

import (
	"fmt"
	"sync"
	"time"
)

type Item struct {
	fid    int32
	vsz    int32
	vpos   int32
	tstamp int64
}

// Keydir is a index data structure for bitcask
// It wrap for hashmap(builtin go)
// It is safe to call Add, remove, Get concurrently.
type Keydir struct {
	sync.RWMutex
	kv map[string]*Item
}

func NewKeydir() *Keydir {
	return &Keydir{
		kv: make(map[string]*Item),
	}
}

func (k *Keydir) Add(key string, fid, vsz, vpos int32, tstamp int64) error {
	k.Lock()
	defer k.Unlock()

	k.kv[key] = &Item{fid, vsz, vpos, tstamp}

	return nil
}

func (k *Keydir) Get(key string) (*Item, bool) {
	k.RLock()
	defer k.RUnlock()

	v, b := k.kv[key]
	return v, b
}

func (k *Keydir) remove(key string) {
	k.Lock()
	defer k.Unlock()

	delete(k.kv, key)
}
func (k *Keydir) destroy() {

}

const N int = 1024 * 1024 * 10 // 10M

/*
Benchmark
Add  +5.352102e+000
Add 1868424.866574 ops/sec
Get  +3.851814e+000
Get 2596179.581708 ops/sec
*/

/*

Add  +1.845055e+001
Add 568316.891196 ops/sec
Get  +9.290991e+000
Get 1128594.318008 ops/sec
*/

func main() {
	kv := NewKeydir()
	t0 := time.Now()
	for i := 0; i < N; i++ {
		kv.Add(fmt.Sprintf("%010d", i), 1, 1, 1, 1)
	}
	t1 := time.Now()
	println("Add ", t1.Sub(t0).Seconds())
	print(fmt.Sprintf("Add %f ops/sec\n", float64(N)/t1.Sub(t0).Seconds()))

	t0 = time.Now()
	for i := 0; i < N; i++ {
		item, e := kv.Get(fmt.Sprintf("%010d", i))
		if !e || item.tstamp != 1 {
			print("Failed to Get correct item")
		}
	}
	t1 = time.Now()
	println("Get ", t1.Sub(t0).Seconds())
	print(fmt.Sprintf("Get %f ops/sec\n", float64(N)/t1.Sub(t0).Seconds()))

	kv.destroy()
}

//950575.158332 ops/sec
