package main

import (
	"../bitcask"
	"flag"
	"fmt"
	"log"
	"math/rand"
	"os"
	"runtime"
	"strconv"
	"time"
)

const testDirPath = "/home/jwzh/tmpdata/testData"

var t *string = flag.String("t", "W", "")
var N *int = flag.Int("n", 1000, "")
var vsz *string = flag.String("sz", "1K", "")

func genValue(size int) []byte {
	v := make([]byte, size)
	for i := 0; i < size; i++ {
		v[i] = uint8((rand.Int() % 26) + 97) // a-z
	}
	return v
}

//a_b
func benchSet(s *caskdb.Store, N, vsz int) time.Duration {
	value := genValue(vsz)
	t0 := time.Now()
	for j := 0; j < N; j++ {
		key := fmt.Sprintf("%d_%d", j%16, j)
		err := s.Set(key, value)
		if err != nil {
			log.Fatalf("Error %s while Seting %s", err.Error(), key)
		}
	}
	t1 := time.Now()
	return t1.Sub(t0)
}

func benchSetMulti(s *caskdb.Store, N, vsz int) time.Duration {
	values := make([][]byte, N)
	keys := make([]string, N)
	value := genValue(vsz)
	for j := 0; j < N; j++ {
		keys[j] = fmt.Sprintf("%d_%d", j%16, j)
		copy(values[j], value)
	}

	t0 := time.Now()
	err := s.SetMulti(keys, values)
	if err != nil {
		log.Fatalf("Error %s while Seting", err.Error())
	}
	t1 := time.Now()
	return t1.Sub(t0)
}

func benchGet(s *caskdb.Store, N, vsz int) time.Duration {
	value := genValue(vsz)
	for j := 0; j < N; j++ {
		key := fmt.Sprintf("%d_%d", j%16, j)
		err := s.Set(key, value)
		if err != nil {
			log.Fatalf("Error %s while Seting %s", err.Error(), key)
		}
	}
	s.Sync()
	kv := make([]int, N)
	for i := 0; i < N; i++ {
		kv[i] = rand.Intn(N)
	}
	t0 := time.Now()
	for j := 0; j < N; j++ {
		key := fmt.Sprintf("%d_%d", kv[j]%16, kv[j])
		_, err := s.Get(key)
		if err != nil {
			log.Fatalf("Error %s while Geting %s", err.Error(), key)
		}
	}
	t1 := time.Now()
	return t1.Sub(t0)
}

func main() {
	flag.Parse()
	runtime.GOMAXPROCS(4)
	os.RemoveAll(testDirPath)
	s, _ := caskdb.NewStore(testDirPath, 8*1024*1024, 16)

	f := func(s string) int {
		ret, _ := strconv.Atoi(s[:len(s)-1])
		switch s[len(s)-1] {
		case 'B':
			return ret
		case 'K':
			return ret * 1024
		case 'M':
			return ret * 1024 * 1024
		}
		return ret
	}

	fmt.Printf("Benchmark %s vsz = %s, ", *t, *vsz)
	var du time.Duration
	switch *t {
	case "W":
		du = benchSet(s, *N, f(*vsz))
	case "R":
		du = benchGet(s, *N, f(*vsz))
	case "MW":
		du = benchSetMulti(s, *N, f(*vsz))
	}
	fmt.Printf("%f ops/sec\n", float64(*N)/du.Seconds())

	t0 := time.Now()
	s.Close()
	t1 := time.Now()
	fmt.Printf("disk: %f ops/sec ", float64(*N)/(du.Seconds()+t1.Sub(t0).Seconds()))

	return
}
